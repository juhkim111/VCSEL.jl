
# Variance component selection for a univariate response model

## Simulation using `SKAT.haplotypes` data in R `SKAT` package

### Generate data 

The package `VarianceComponentSelect` has not yet been registered and must be installed using the repository location. Start julia and use the `]` key to switch to the package manager REPL:
```julia
(v1.0) pkg> add https://github.com/juhkim111/VarianceComponentSelect.jl
```
Use the backspace key to return to the Julia REPL.


```julia
using VarianceComponentSelect
```

    ┌ Info: Recompiling stale cache file /Users/juhyun-kim/.julia/compiled/v1.0/VarianceComponentSelect/iiLmX.ji for VarianceComponentSelect [684d1ed6-5d62-11e9-0c0b-878d753c12b1]
    └ @ Base loading.jl:1184
    ┌ Warning: Package VarianceComponentSelect does not have Plots in its dependencies:
    │ - If you have VarianceComponentSelect checked out for development and have
    │   added Plots as a dependency but haven't updated your primary
    │   environment's manifest file, try `Pkg.resolve()`.
    │ - Otherwise you may need to report an issue with VarianceComponentSelect
    └ Loading Plots into VarianceComponentSelect from project dependency, future warnings for VarianceComponentSelect are suppressed.


We use haplotype data ([`SKAT.haplotypes`](https://cran.r-project.org/web/packages/SKAT/SKAT.pdf#page=23)) in R [`SKAT`](https://cran.r-project.org/web/packages/SKAT/SKAT.pdf) package to generate genotype matrix. This dataset is generated by calibration coalescent model (COSI) with mimicking LD structure of European ancestry.
Load `RCall` package, which allows us to call R packages from within Julia.


```julia
using RCall
```


```julia
R"""
    packages <- c("SKAT", "gglasso")
    if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
    install.packages(setdiff(packages, rownames(installed.packages())))
    }
    library(SKAT)
    data("SKAT.haplotypes")
    Haplotype <- SKAT.haplotypes$Haplotype
    SNPInfo <- SKAT.haplotypes$SNPInfo
""";
```

`SKAT.haplotypes` consists of two objects: `Haplotype` matrix and `SNPInfo` dataframe.
`Haplotype` is a matrix of size $10,000\times 3845$ where each row represents a different haplotype and each column represents a different SNP marker. 


```julia
@rget Haplotype
```




    10000×3845 Array{Int64,2}:
     0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  1  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  0  1  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  1  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  1  0  0  0  0  0  0  0     0  0  0  0  1  0  1  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  1  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     ⋮              ⋮              ⋮        ⋱        ⋮              ⋮            
     0  0  0  0  0  1  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  1  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  1  1  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  1  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0



`SNPInfo` contains information about 3,845 SNPs in `Haplotype` matrix. All SNPs come from chromosome 1, and chromosome position ranges from 79 to 199956, or over 200k base pair region. 


```julia
@rget SNPInfo
```




<table class="data-frame"><thead><tr><th></th><th>SNP</th><th>CHROM</th><th>CHROM_POS</th><th>ALLELE1</th><th>FREQ1</th><th>ALLELE2</th><th>FREQ2</th></tr><tr><th></th><th>Int64</th><th>Int64</th><th>Int64</th><th>Int64</th><th>Float64</th><th>Int64</th><th>Float64</th></tr></thead><tbody><p>3,845 rows × 7 columns</p><tr><th>1</th><td>1</td><td>1</td><td>79</td><td>1</td><td>0.0008</td><td>2</td><td>0.9992</td></tr><tr><th>2</th><td>2</td><td>1</td><td>281</td><td>1</td><td>0.0001</td><td>2</td><td>0.9999</td></tr><tr><th>3</th><td>3</td><td>1</td><td>344</td><td>1</td><td>0.0001</td><td>2</td><td>0.9999</td></tr><tr><th>4</th><td>4</td><td>1</td><td>385</td><td>1</td><td>0.001</td><td>2</td><td>0.999</td></tr><tr><th>5</th><td>5</td><td>1</td><td>403</td><td>1</td><td>0.0011</td><td>2</td><td>0.9989</td></tr><tr><th>6</th><td>6</td><td>1</td><td>428</td><td>1</td><td>0.1387</td><td>2</td><td>0.8613</td></tr><tr><th>7</th><td>7</td><td>1</td><td>501</td><td>1</td><td>0.1051</td><td>2</td><td>0.8949</td></tr><tr><th>8</th><td>8</td><td>1</td><td>536</td><td>1</td><td>0.0011</td><td>2</td><td>0.9989</td></tr><tr><th>9</th><td>9</td><td>1</td><td>607</td><td>1</td><td>0.0015</td><td>2</td><td>0.9985</td></tr><tr><th>10</th><td>10</td><td>1</td><td>612</td><td>1</td><td>0.0002</td><td>2</td><td>0.9998</td></tr><tr><th>11</th><td>11</td><td>1</td><td>739</td><td>1</td><td>0.0008</td><td>2</td><td>0.9992</td></tr><tr><th>12</th><td>12</td><td>1</td><td>808</td><td>1</td><td>0.0003</td><td>2</td><td>0.9997</td></tr><tr><th>13</th><td>13</td><td>1</td><td>819</td><td>1</td><td>0.0002</td><td>2</td><td>0.9998</td></tr><tr><th>14</th><td>14</td><td>1</td><td>831</td><td>1</td><td>0.0002</td><td>2</td><td>0.9998</td></tr><tr><th>15</th><td>15</td><td>1</td><td>965</td><td>1</td><td>0.0068</td><td>2</td><td>0.9932</td></tr><tr><th>16</th><td>16</td><td>1</td><td>990</td><td>1</td><td>0.0001</td><td>2</td><td>0.9999</td></tr><tr><th>17</th><td>17</td><td>1</td><td>1190</td><td>1</td><td>0.0001</td><td>2</td><td>0.9999</td></tr><tr><th>18</th><td>18</td><td>1</td><td>1245</td><td>1</td><td>0.1688</td><td>2</td><td>0.8312</td></tr><tr><th>19</th><td>19</td><td>1</td><td>1279</td><td>1</td><td>0.0001</td><td>2</td><td>0.9999</td></tr><tr><th>20</th><td>20</td><td>1</td><td>1584</td><td>1</td><td>0.0003</td><td>2</td><td>0.9997</td></tr><tr><th>21</th><td>21</td><td>1</td><td>1722</td><td>1</td><td>0.0189</td><td>2</td><td>0.9811</td></tr><tr><th>22</th><td>22</td><td>1</td><td>1723</td><td>1</td><td>0.0003</td><td>2</td><td>0.9997</td></tr><tr><th>23</th><td>23</td><td>1</td><td>1761</td><td>1</td><td>0.006</td><td>2</td><td>0.994</td></tr><tr><th>24</th><td>24</td><td>1</td><td>1830</td><td>1</td><td>0.0826</td><td>2</td><td>0.9174</td></tr><tr><th>25</th><td>25</td><td>1</td><td>1855</td><td>1</td><td>0.1116</td><td>2</td><td>0.8884</td></tr><tr><th>26</th><td>26</td><td>1</td><td>1886</td><td>1</td><td>0.0005</td><td>2</td><td>0.9995</td></tr><tr><th>27</th><td>27</td><td>1</td><td>1985</td><td>1</td><td>0.0004</td><td>2</td><td>0.9996</td></tr><tr><th>28</th><td>28</td><td>1</td><td>2020</td><td>1</td><td>0.0005</td><td>2</td><td>0.9995</td></tr><tr><th>29</th><td>29</td><td>1</td><td>2042</td><td>1</td><td>0.0197</td><td>2</td><td>0.9803</td></tr><tr><th>30</th><td>30</td><td>1</td><td>2083</td><td>1</td><td>0.1045</td><td>2</td><td>0.8955</td></tr><tr><th>&vellip;</th><td>&vellip;</td><td>&vellip;</td><td>&vellip;</td><td>&vellip;</td><td>&vellip;</td><td>&vellip;</td><td>&vellip;</td></tr></tbody></table>



Assume one gene to be 5kb long, which translates to having 40 genes. We also assume sample size to be 500.


```julia
m = 40 # no. of genes
pj = 5000 # gene size 
n = 500 # sample size
```




    500



Suppose that there are 5 causal genes, and that they are evenly spread across all 40 genes/groups. 


```julia
σ2 = zeros(m + 1)
σ2[end] = 1.0
for iter in Int.(round.(range(1, stop=m, length=5)))
     σ2[iter] = 5.0
end
```

These genes have positive variance components:


```julia
Int.(round.(range(1, stop=m, length=5)))
```




    5-element Array{Int64,1}:
      1
     11
     20
     30
     40



Set seed first. 


```julia
using Random
Random.seed!(123);
```

To create a genotype matrix whose entries consist of {0,1,2}, we select `2n` rows from `Haplotype` without replacement and add the first `n` rows to the last `n` rows.


```julia
using StatsBase, LinearAlgebra
n = 500 # sample sizE 
idx = zeros(Int64, 2n)
sample!(1:size(Haplotype, 1), idx; replace=false)

# add two haplotype matrices to create a big block of genotype matrix
G = Haplotype[idx[1:n], :] + Haplotype[idx[n + 1:end], :]
```




    500×3845 Array{Int64,2}:
     0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  1  0  1  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  1  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  1  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  0  1  0  0  0  0  0  0     0  0  0  0  0  0  2  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  2  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  1  0  0  0  0  0  0  0  …  0  0  0  0  0  0  2  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     ⋮              ⋮              ⋮        ⋱        ⋮              ⋮            
     0  0  0  0  0  1  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  0  1  0  0  0  0  0  0  …  0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  1  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  0  1  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  1  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  1  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
     0  0  0  0  0  1  0  0  0  0  0  0  0     0  0  0  0  0  0  1  0  0  0  0  0
     0  0  0  0  0  0  1  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0



Now we construct covariance matrix `V[i]` for gene `i` by dividing up `G` matrix by chromosome position (5kb), multiplying by its transpose, and dividing by its Frobenius norm. 
Ultimately, we add these covariance matrices multiplied by variance component to create the overall covariance matrix `Ω`.


```julia
## construct covariance matrix Ω
Ω  = zeros(n, n)
grp_id = zeros(Int64, size(Haplotype, 2))
V  = Array{Matrix{Float64}}(undef, m + 1)
for k in 1:m
    local k
    i = k
    grp_id[(SNPInfo.CHROM_POS .> pj * (i-1)) .& (SNPInfo.CHROM_POS .<= pj * i)] .= i
    Vi = view(G, :, grp_id .== i)
    V[i] = Vi * Vi'
    V[i] ./= norm(V[i])
    Ω .+= σ2[i] .* V[i]
end
V[m + 1] = Matrix{Float64}(I, n, n) ./ √n
Ω .+= σ2[m + 1] .* V[m + 1]
Ωchol = cholesky(Symmetric(Ω)) # cholesky factorization after making it symmetric 
```




    Cholesky{Float64,Array{Float64,2}}
    U factor:
    500×500 UpperTriangular{Float64,Array{Float64,2}}:
     0.286665  0.0308989  0.0         0.0929487   …   0.0           0.0189187  
      ⋅        0.314658   0.0736505   0.0190226       0.101801      0.0264071  
      ⋅         ⋅         0.31854    -0.00439827      0.104943      0.0218148  
      ⋅         ⋅          ⋅          0.351454        0.0575279     0.0555649  
      ⋅         ⋅          ⋅           ⋅              0.0366417     0.0350243  
      ⋅         ⋅          ⋅           ⋅          …   0.0636818     0.0445843  
      ⋅         ⋅          ⋅           ⋅              0.0735116     0.0241263  
      ⋅         ⋅          ⋅           ⋅              0.0334636    -0.0561523  
      ⋅         ⋅          ⋅           ⋅             -0.0718995     0.118174   
      ⋅         ⋅          ⋅           ⋅              0.0737071    -0.00769136 
      ⋅         ⋅          ⋅           ⋅          …   0.00933045    0.00570924 
      ⋅         ⋅          ⋅           ⋅             -0.014867      0.012746   
      ⋅         ⋅          ⋅           ⋅              0.0403189    -0.00854823 
     ⋮                                            ⋱                            
      ⋅         ⋅          ⋅           ⋅              0.0045296    -0.00181669 
      ⋅         ⋅          ⋅           ⋅             -0.00123152    0.00259173 
      ⋅         ⋅          ⋅           ⋅          …   0.000440328   0.0016991  
      ⋅         ⋅          ⋅           ⋅              0.000947484   0.000529841
      ⋅         ⋅          ⋅           ⋅             -0.00127865   -0.000652502
      ⋅         ⋅          ⋅           ⋅             -0.00173592    0.00325268 
      ⋅         ⋅          ⋅           ⋅             -0.00100727   -0.000420654
      ⋅         ⋅          ⋅           ⋅          …  -0.00138927    0.00551104 
      ⋅         ⋅          ⋅           ⋅             -0.000589728  -0.000973307
      ⋅         ⋅          ⋅           ⋅              0.0028112    -0.000481491
      ⋅         ⋅          ⋅           ⋅              0.22908      -0.00141437 
      ⋅         ⋅          ⋅           ⋅               ⋅            0.217768   



We also generate a covariate matrix with 10 covariates. 


```julia
p = 10
X = randn(n, p)
```




    500×10 Array{Float64,2}:
      0.208919   -0.357512  -1.20512   …  -2.28353    0.469279   -0.4246    
      0.196372    1.10493    0.510995      0.94911    1.05211     0.190831  
     -0.964934    0.360943  -0.797932     -0.136343  -0.607956    0.0199318 
      0.17751     1.07779    1.01809      -1.60784    0.775929   -0.412176  
      1.59153     0.211548   0.887211     -0.899853  -2.34106     0.0259707 
     -0.151672   -2.1254    -1.2528    …   1.39219    0.47917     0.170861  
     -2.63614     1.04942    1.20896      -0.256876  -0.458283   -0.667652  
      0.822095   -0.354441   0.197945     -0.372056   0.313368   -0.358023  
     -1.30325    -0.160404  -0.613613      0.881436   1.7622     -1.33322   
     -1.1814     -0.60608    0.557166     -0.657915  -1.65057     0.969906  
      2.23366     0.43255    0.968414  …   2.48333    1.7669      0.172893  
      1.13666    -1.24071   -0.819892      1.15584    1.17051     0.531119  
     -1.09657    -0.528542  -1.16037      -0.772672  -0.416337   -0.168258  
      ⋮                                ⋱                                    
      0.824788   -1.67615   -0.472136      0.282546   0.860705   -0.606173  
      0.216596    0.212162   1.03849       0.670802  -0.995205   -1.43156   
     -0.0491363  -0.661038   0.424151  …   1.05502   -3.23621    -0.29664   
     -0.87218     0.371671  -0.599162     -0.352578   1.18965     0.00425142
      1.25181     0.119844  -0.105837     -0.643643   0.446714   -0.208301  
      0.405704   -0.676135   0.35366       2.43627   -0.0896436   1.2424    
      0.496721   -0.662983  -0.884039     -0.151464  -0.443486   -1.25671   
      0.615306    0.54363   -1.028     …  -1.17897   -0.0296757  -0.312401  
      0.201315   -1.48729    0.644132     -0.310615  -0.871628    1.15615   
     -0.206151   -0.61825   -0.102662     -0.129348   0.726759    1.28837   
      0.475409    1.80971    0.650056     -0.704587   0.0736413  -2.07289   
     -1.44201    -0.699842  -0.69557      -1.01168   -1.51068     1.60719   



Finally, we create a response vector using the Cholesky factorization.


```julia
β = ones(p)
y = X * β + Ωchol.L * randn(n) 
```




    500-element Array{Float64,1}:
     -4.545804720152172 
      9.554438488673872 
     -2.2192477506797488
     -2.0143970037761805
      0.1104655736896164
     -3.875815486848486 
      1.3821967784546783
      2.313158560447355 
     -4.416332034149308 
     -3.8306940844226953
      6.857835924330509 
      5.754666454741338 
     -2.9589237786495675
      ⋮                 
      0.4678309058131852
      2.35901109726784  
     -4.2082139307110165
     -0.6635539857801465
      2.619826684097063 
      5.3827763283445185
     -2.2602354367020547
      2.601577888797258 
      0.589233811611282 
     -1.3458128723463212
     -1.3938624805614621
     -2.4166872919288918



### Perform variance component selection

Finally, we are ready to perform variance component selection. 


```julia
using PenaltyFunctions
```

First, let's estimate `σ2` using no penalty.


```julia
@time σ2, beta, obj, niters, = vcselect(y, X, V)
```

      9.591699 seconds (12.91 M allocations: 1.135 GiB, 3.95% gc time)





    ([5.59277, 3.68246e-25, 4.05807e-46, 1.90584e-86, 8.34901e-43, 8.41528e-78, 4.1108e-26, 5.25669e-49, 1.19083e-41, 2.85301e-37  …  3.58045e-67, 1.4752e-27, 7.6159e-23, 2.22303e-34, 5.07508e-22, 6.89541e-22, 3.39076e-90, 2.82245e-27, 10.3486, 0.0412181], [0.989949, 1.00208, 0.992591, 1.0178, 0.977201, 0.983245, 0.972788, 1.00255, 1.0127, 1.01165], 0.5911239450693984, 215, [0.0653868 0.0290428 … 0.0379614 0.0100729; 0.0290428 0.0805443 … 0.071907 0.0142363; … ; 0.0379614 0.071907 … 0.227774 0.00171365; 0.0100729 0.0142363 … 0.00171365 0.143608])



Variance component estimates are as follows. 


```julia
σ2
```




    41-element Array{Float64,1}:
      5.592767124720296     
      3.682459758361709e-25 
      4.058074836451268e-46 
      1.905839347200065e-86 
      8.34901223865387e-43  
      8.415279163673975e-78 
      4.1107973353850115e-26
      5.25669179999587e-49  
      1.1908304351240828e-41
      2.853007637112469e-37 
      6.2937137027976044    
      0.07080079157485043   
      1.222127929269664e-33 
      ⋮                     
      5.196141030492298     
      3.138853220308318e-11 
      3.580454157462937e-67 
      1.4751963109486538e-27
      7.615898930535465e-23 
      2.2230334982604183e-34
      5.07508459165853e-22  
      6.895409339511374e-22 
      3.3907596170630264e-90
      2.822445904309661e-27 
     10.348629052624428     
      0.04121807160779722   



Fixed effects estimates are as follows: 


```julia
beta
```




    10-element Array{Float64,1}:
     0.9899492014759339
     1.0020846416081508
     0.9925908701019324
     1.0177993160597432
     0.9772006322106234
     0.9832449087434227
     0.9727878914828767
     1.0025457930917654
     1.0126953158880256
     1.0116453919900765



We can use the estimates above as a penalty weight for adaptive lasso penalty. 


```julia
penwt = zeros(m + 1)
penwt[1:m] = 1 ./ sqrt.(σ2[1:m])
```




    40-element Array{Float64,1}:
          0.42285028911379097  
          1.6479005367491548e12
          4.964093741958963e22 
          7.243639953892643e42 
          1.0944160440918387e21
          3.447194087585017e38 
          4.932157843328997e12 
          1.3792523813657523e24
          2.8978442320668554e20
          1.8721840152100588e18
          0.3986084568114029   
          3.7582091308650236   
          2.8604981118338996e16
          ⋮                    
          0.7237874210027392   
          0.43869181855223205  
     178490.2493272619         
          1.671209675006296e33 
          2.60360496566547e13  
          1.1458807246161131e11
          6.706979771521684e16 
          4.438930621609514e10 
          3.808201972270091e10 
          5.430646061754621e44 
          1.8822928240441496e13
          0.31085552451869497  



Here we obtain solution path using three different penalties: lasso (`L1Penalty()`), adaptive lasso, and MCP penalty (`MCPPenalty()`). For MCP penalty, default `γ` value equals to 2.0.


```julia
# lasso penalty 
@time σ2path_lasso, objpath_lasso, λpath_lasso, _, betapath_lasso = 
        vcselectpath(y, X, V; penfun=L1Penalty(), fixedestimates=true)
```

     72.692033 seconds (24.09 M allocations: 11.958 GiB, 3.69% gc time)





    ([5.59277 5.54081 … 0.0 0.0; 3.68246e-25 0.0 … 0.0 0.0; … ; 10.3486 7.69842 … 0.204147 0.200669; 0.0412181 0.0437345 … 0.144573 0.144742], [0.591124, 11.5374, 20.5191, 28.1553, 35.413, 42.2677, 48.7818, 55.0024, 60.9664, 66.7034  …  283.66, 285.026, 279.597, 271.896, 272.262, 272.625, 272.985, 273.342, 273.696, 274.048], 0.0:0.7784919476286355:77.07070281523491, [215, 145, 146, 64, 21, 21, 20, 20, 20, 20  …  58, 81, 54, 49, 21, 22, 22, 22, 23, 23], [0.989949 0.992638 … 0.981192 0.981196; 1.00208 1.0011 … 0.992258 0.992264; … ; 1.0127 1.00852 … 1.01112 1.01109; 1.01165 1.01493 … 1.01291 1.01293])




```julia
# adaptive lasso penalty 
@time σ2path_adlasso, objpath_adlasso, λpath_adlasso, _, betapath_adlasso = 
        vcselectpath(y, X, V; penfun=L1Penalty(), penwt=penwt, 
        fixedestimates=true)
```

     50.714407 seconds (56.16 k allocations: 10.068 GiB, 3.86% gc time)





    ([5.59277 5.19157 … 0.0 0.0; 3.68246e-25 0.0 … 0.0 0.0; … ; 10.3486 7.59767 … 0.165294 0.161908; 0.0412181 0.0436701 … 0.1467 0.146923], [0.591124, 21.1507, 35.5131, 48.206, 59.7404, 68.5643, 77.8559, 86.6149, 94.9186, 102.827  …  274.804, 275.188, 275.569, 275.946, 276.32, 276.69, 277.057, 277.42, 277.779, 278.134], 0.0:2.815460542362373:278.73059369387494, [215, 70, 38, 24, 29, 66, 21, 20, 20, 20  …  24, 24, 25, 26, 26, 27, 28, 28, 29, 30], [0.989949 0.993277 … 0.981235 0.981239; 1.00208 0.999611 … 0.992336 0.992344; … ; 1.0127 1.00793 … 1.01083 1.01081; 1.01165 1.01014 … 1.01306 1.01307])




```julia
# mcp penalty with default gamma value (2.0) 
@time σ2path_mcp2, objpath_mcp2, λpath_mcp2, _, betapath_mcp2 = 
        vcselectpath(y, X, V; penfun=MCPPenalty(), fixedestimates=true)
```

     85.900394 seconds (9.49 M allocations: 15.897 GiB, 4.10% gc time)





    ([5.59277 5.56862 … 0.0 0.0; 3.68246e-25 0.0 … 0.0 0.0; … ; 10.3486 10.2145 … 0.2056 0.202262; 0.0412181 0.0413365 … 0.144442 0.144593], [0.591124, 6.82498, 13.0574, 19.2529, 25.9859, 31.7846, 37.9087, 43.9302, 49.804, 55.5265  …  264.161, 265.784, 267.403, 269.021, 270.638, 273.187, 269.073, 269.455, 269.833, 270.208], 0.0:0.7799661780559084:77.21665162753493, [215, 125, 95, 86, 107, 53, 49, 49, 49, 49  …  70, 74, 80, 87, 99, 162, 40, 34, 34, 35], [0.989949 0.991494 … 0.98119 0.981194; 1.00208 1.00155 … 0.992255 0.992261; … ; 1.0127 1.01291 … 1.01113 1.01111; 1.01165 1.00871 … 1.01291 1.01292])



### Plot solution path 

In this section, we plot solution paths. 

First, we plot solution paths from lasso penalty. Note the following solution path. 


```julia
σ2path_lasso
```




    41×100 Array{Float64,2}:
      5.59277      5.54081    5.08605    …  0.0       0.0       0.0     
      3.68246e-25  0.0        0.0           0.0       0.0       0.0     
      4.05807e-46  0.0        0.0           0.0       0.0       0.0     
      1.90584e-86  0.0        0.0           0.0       0.0       0.0     
      8.34901e-43  0.0        0.0           0.0       0.0       0.0     
      8.41528e-78  0.0        0.0        …  0.0       0.0       0.0     
      4.1108e-26   0.0        0.0           0.0       0.0       0.0     
      5.25669e-49  0.0        0.0           0.0       0.0       0.0     
      1.19083e-41  0.0        0.0           0.0       0.0       0.0     
      2.85301e-37  0.0        0.0           0.0       0.0       0.0     
      6.29371      5.30213    4.30805    …  0.0       0.0       0.0     
      0.0708008    0.0        0.0           0.0       0.0       0.0     
      1.22213e-33  0.0        0.0           0.0       0.0       0.0     
      ⋮                                  ⋱                              
      5.19614      4.25716    3.39927       0.0       0.0       0.0     
      3.13885e-11  0.0        0.0        …  0.0       0.0       0.0     
      3.58045e-67  0.0        0.0           0.0       0.0       0.0     
      1.4752e-27   0.0        0.0           0.0       0.0       0.0     
      7.6159e-23   0.0        0.0           0.0       0.0       0.0     
      2.22303e-34  0.0        0.0           0.0       0.0       0.0     
      5.07508e-22  0.0        0.0        …  0.0       0.0       0.0     
      6.89541e-22  0.0        0.0           0.0       0.0       0.0     
      3.39076e-90  0.0        0.0           0.0       0.0       0.0     
      2.82245e-27  0.0        0.0           0.0       0.0       0.0     
     10.3486       7.69842    6.11937       0.207268  0.204147  0.200669
      0.0412181    0.0437345  0.0452045  …  0.144449  0.144573  0.144742



Each column represents estimated variance component at specific $\lambda$. The dimension verfies this fact; 41 rows and 100 columnns represent 41 variance components and 100 tuning parameter values, respectively. From left to right, $\lambda$ value is supposed to increase, which can be verified by displaying `λpath_lasso`.


```julia
λpath_lasso
```




    0.0:0.7784919476286355:77.07070281523491



For plotting, we will use `gr()` backend. For different options of backends, refer to [the manual](http://docs.juliaplots.org/latest/backends/).


```julia
using Plots; gr()
```




    Plots.GRBackend()




```julia
plotsolpath(σ2path_lasso, λpath_lasso; 
    title="Solution Path (lasso penalty)", xlab="\\lambda", ylab="\\sigma^2",
    linewidth=1.2)
```




![svg](output_51_0.svg)




```julia
plotsolpath(σ2path_adlasso, λpath_adlasso; 
    title="Solution Path (adaptive lasso penalty)", 
    xlab="\\lambda", ylab="\\sigma^2", linewidth=1.2)
```




![svg](output_52_0.svg)




```julia
plotsolpath(σ2path_mcp2, λpath_mcp2; 
    title="Solution Path (MCP penalty, \\gamma=2.0)", 
    xlab="\\lambda", ylab="\\sigma^2", linewidth=1.2)
```




![svg](output_53_0.svg)



For MCP penalty, we used the default value `γ=2.0`. Instead, let's try `γ=2.69`, and plot the solution path. 


```julia
@time σ2path_mcp269, objpath_mcp269, λpath_mcp269 = 
        vcselectpath(y, X, V; penfun=MCPPenalty(2.69))
```

     93.202163 seconds (78.40 k allocations: 13.425 GiB, 4.61% gc time)





    ([5.59277 5.58026 … 0.0 0.0; 3.68246e-25 0.0 … 0.0 0.0; … ; 10.3486 10.1988 … 0.205045 0.201714; 0.0412181 0.0413791 … 0.144468 0.144619], [0.591124, 8.51234, 16.3563, 23.2846, 30.6362, 36.7403, 43.1315, 49.3383, 55.3611, 61.206  …  269.321, 270.89, 272.452, 274.008, 275.56, 275.59, 270.128, 270.504, 270.876, 271.246], 0.0:0.7806541522553025:77.28476107327495, [215, 117, 26, 74, 103, 49, 46, 46, 46, 46  …  68, 73, 78, 86, 99, 155, 38, 33, 33, 34])




```julia
plotsolpath(σ2path_mcp269, λpath_mcp269; 
    title="Solution Path (MCP penalty, \\gamma=2.69)", 
    xlab="\\lambda", ylab="\\sigma^2", linewidth=1.2)
```




![svg](output_56_0.svg)


